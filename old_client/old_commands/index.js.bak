const {
    Client,
    Intents,
    Collection,
    ActionRowBuilder, 
    ButtonBuilder,
    EmbedBuilder,
    ButtonStyle,
    GatewayIntentBits 
} = require('discord.js');
const { generateDependencyReport, joinVoiceChannel, getVoiceConnection, createAudioPlayer, VoiceConnectionStatus, entersState, createAudioResource } = require('@discordjs/voice');
const { addSpeechEvent } = require("discord-speech-recognition");
const {
    REST
} = require('@discordjs/rest');
const {
    Routes
} = require('discord-api-types/v9');
const fs = require('fs');
const findRemoveSync = require('find-remove');
const syncfetch = require('sync-fetch')
const config = require("./config.json");
require('events').EventEmitter.prototype._maxListeners = config.MAX_LISTENERS;
const http = require("http");
const wait = require('node:timers/promises').setTimeout;
require( 'console-stamp' )( console );
//const client = new Client({ intents: 32767 });
//const client = new Client({ intents: [32767, GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates] });
const client = new Client({
	intents: [
		GatewayIntentBits.AutoModerationConfiguration,
		GatewayIntentBits.AutoModerationExecution,
		GatewayIntentBits.DirectMessageReactions,
		GatewayIntentBits.DirectMessageTyping,
		GatewayIntentBits.DirectMessages,
		GatewayIntentBits.GuildEmojisAndStickers,
		GatewayIntentBits.GuildIntegrations,
		GatewayIntentBits.GuildInvites,
		GatewayIntentBits.GuildMembers,
		GatewayIntentBits.GuildMessageReactions,
		GatewayIntentBits.GuildMessageTyping,
		GatewayIntentBits.GuildMessages,
		GatewayIntentBits.GuildPresences,
		GatewayIntentBits.GuildScheduledEvents,
		GatewayIntentBits.GuildVoiceStates,
		GatewayIntentBits.GuildWebhooks,
		GatewayIntentBits.Guilds,
		GatewayIntentBits.MessageContent
	],
});

addSpeechEvent(client, { lang: "it-IT", profanityFilter: false });

console.log(generateDependencyReport());

const cron = require('node-cron');

const TOKEN = config.BOT_TOKEN;
const path = config.CACHE_DIR;
const GUILD_ID = config.GUILD_ID;
const MESSAGES_CHANNEL_ID = config.MESSAGES_CHANNEL_ID;


cron.schedule('0 */5 * * * *', () => {
    var age_param = { seconds: 7200 };
    var extensions_param = '.mp3';
    findRemoveSync(config.CACHE_DIR, {
        age: age_param,
        extensions: extensions_param
      });
    //console.log("Deleting old mp3 files...", "[config.CACHE_DIR: " + config.CACHE_DIR +"]", "[age: " + JSON.stringify(age_param) +"]", "[extensions: "+ extensions_param +"]");  
                                               
});

let connection;

function unsubscribeConnection() {
    if ( connection !== null
        && connection !== undefined 
        && connection.state !== null 
        && connection.state !== undefined 
        && connection.state.subscription !== null
        && connection.state.subscription !== undefined) {
        connection.state.subscription.unsubscribe();
    } 
}

const player = createAudioPlayer();

player.on('error', error => {
    console.error("ERRORE!", "["+ error + "]");  
});

const fetch = require('node-fetch');

const api=config.API_URL;
const port=config.API_PORT;
const hostname=config.API_HOSTNAME;
const path_audio=config.API_PATH_AUDIO;
const path_music=config.API_PATH_MUSIC;
const path_text=config.API_PATH_TEXT;
let lastSpeech = 0;

//setInterval(findRemoveSync.bind(this, path, { extensions: ['.mp3', '.mp3'] }), 21600000)

const commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));

let playAsStream = true;


const commands = [];

client.commands = new Collection();

for (const file of commandFiles) {
    const command = require(`./commands/${file}`);
    //commands.push(command.data.toJSON());
    client.commands.set(command.data.name, command);
}

/**client.on('ready', () => {
    const rest = new REST({ version: '9' }).setToken(config.BOT_TOKEN);

    (async () => {
        try {
            console.log('Started refreshing application (/) commands.');

            await rest.put(
                Routes.applicationGuildCommands(config.BOT_ID, config.GUILD_ID),
                { body: commands },
            );

            console.log('Successfully reloaded application (/) commands.');
        } catch (error) {
            console.error(error);
        }
    })();
});*/

client.on('voiceStateUpdate', (oldMember, newMember) => {
  try{            
      if (newMember?.channelId) {
        client.channels.fetch(newMember?.channelId)
                .then(channel => {
            
                if (newMember?.channelId === config.ENABLED_CHANNEL_ID_1
                    || newMember?.channelId === config.ENABLED_CHANNEL_ID_2
                    || newMember?.channelId === config.ENABLED_CHANNEL_ID_3){   
                    const connection_old = getVoiceConnection(newMember?.guild.id);
                    if ((connection_old === undefined 
                        || connection_old === null) 
                        || 
                        (connection_old !== null 
                        && connection_old !== undefined
                        && connection_old.joinConfig.channelId !== newMember?.channelId)){
                            if (connection_old !== undefined 
                                && connection_old !== null) {
                                    connection_old.destroy();
                                }
                        connection = joinVoiceChannel({
                            channelId: newMember?.channelId,
                            guildId: newMember?.guild.id,
                            adapterCreator: channel.guild.voiceAdapterCreator,
                            selfDeaf: false,
                            selfMute: false
                        });

                        connection.on(VoiceConnectionStatus.Disconnected, async (oldState, newState) => {
                            try {
                                await Promise.race([
                                    entersState(connection, VoiceConnectionStatus.Signalling, 5_000),
                                    entersState(connection, VoiceConnectionStatus.Connecting, 5_000),
                                ]);
                                // Seems to be reconnecting to a new channel - ignore disconnect
                            } catch (error) {
                                // Seems to be a real disconnect which SHOULDN'T be recovered from
                                connection.destroy();
                            }
                        });
                } else {
                        connection = connection_old;
                }
            }
        }).catch(function(error) {
            console.error("ERRORE!", "["+ error + "]");
        });
      }
  } catch (error) {
      console.error(error);
  }
});

function postDeleteReply(interaction, msg) {
	return new Promise(resolve => {
        interaction.reply({ content: msg, ephemeral: false });  
		setTimeout(() => interaction.deleteReply(), 10000);
	});
}

function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}



client.on('interactionCreate', async interaction => {
    try{
        if (!interaction.isStringSelectMenu() && !interaction.isCommand() && !interaction.isButton()) return;
        if (interaction.isCommand()){        
            const command = client.commands.get(interaction.commandName);
            if (!command) return;
            try {
                await command.execute(interaction);
            } catch (error) {
                if (error) console.error(error);
                await interaction.reply({ content: 'Errore!', ephemeral: true });
            }
        } else if (interaction.isButton()){
            if(interaction.customId === 'tournament_regen'){
                var tournamentData = { 
                    'author' : interaction.message.embeds[0].author.name, 
                    'name' : interaction.message.embeds[0].title, 
                    'description' : interaction.message.embeds[0].description
                };
                var bodyData = JSON.stringify(tournamentData)
                const options = {
                    "method": "POST",
                    "hostname": hostname,
                    "port": port,
                    "path": path_text+'tournament/regen',
                    "headers": {
                        'Content-Type': 'application/json',
                        "Content-Length": Buffer.byteLength(bodyData)
                    }
                }
                const req = http.request(options, function(res) {
                    
                    var chunks = [];
                    res.setEncoding('utf8');
                    req.on('error', function (error) {
                        console.error("ERRORE!", "["+ error + "]");
                        interaction.reply({ content: 'Si è verificato un errore', ephemeral: true }); 
                    });

                    res.on("data", function (chunk) {
                        chunks.push(chunk);
                    });
                
                    res.on("end", function() {
                        try {
                            var object = JSON.parse(chunks); 
                            var embed = new EmbedBuilder()
                            .setColor('#0099ff')
                            .setTitle(object.name)
                            .setAuthor({ name: object.author, iconURL: object.author_image, url: '' })
                            .setDescription(object.description)
                            .setThumbnail(object.image)


                            if(object.teamsize == 1){
                                embed.addField('PARTECIPANTI:', '\u200b', false);
                
                                //var fieldsUsers = [];              
                                //var fieldsTeams = [];           
                                //var fieldsRounds = []; 

                                var i = 0;
                                for (i = 0; i < object.users.length; i++) {
                                    var user = object.users[i];
                                    //var fieldsUser = { name: user.username, value: user.title, inline: true }
                                    //fieldsUsers.push(fieldsUser);     
                                    embed.addField(user.username, user.title, true)
                                }
                                
                                if (i%3 !== 0){
                                    while(i%3 !== 0) {
                                        //var fieldsUser = { name: '\u200b', value: '\u200b', inline: true }
                                        //fieldsUsers.push(fieldsUser);     
                                        embed.addField('\u200b', '\u200b', true)
                                        i = i + 1;
                                    }
                                }
                            }
                            if(object.teamsize > 1){
                                embed.addField('\u200b', 'SQUADRE', false)
                            }
                            var k = 0;
                            if (object.teamsize > 1) {
                                for (k = 0; k < object.teams.length; k++) {
                                    var team = object.teams[k];
                                    var users_add = "";
                                    for (var j = 0; j < team.users.length; j++) {
                                        var user = team.users[j];
                                        users_add = user.username + " " + users_add;                    
                                    }                  
                                    var teamName = "";   
                                    if ( team.name === 0) {
                                        teamName = team.users[0].title;
                                    } else {
                                        teamName = team.name;
                                    }
                                    //var fieldsTeam = { name: teamName, value: users_add, inline: true }
                                    //fieldsTeams.push(fieldsTeam);
                                    if(object.teamsize > 1){
                                        embed.addField(teamName, users_add, true)
                                    }
                                }                    
                                if (k%3 !== 0 && object.teamsize > 1){
                                    while(k%3 !== 0) {
                                        //var fieldsTeam = { name: '\u200b', value: '\u200b', inline: true }
                                        //fieldsTeams.push(fieldsTeam);    
                                        embed.addField('\u200b', '\u200b', true) 
                                        k = k + 1;
                                    }
                                }                            
                            }
                            embed.addField('\u200b', 'MATCH GENERATI', false)
                            var h = 0;
                            for (h = 0; h < object.rounds.length; h++) {
                                var round = object.rounds[h];
                                var teams = "";
                                teams = round.teams[0].name + "     VS     " + round.teams[1].name;

                                var user0 = "";
                                for (var j = 0; j < round.teams[0].users.length; j++) {
                                    var user = round.teams[0].users[j];
                                    user0 = user.username + " " + user0;                    
                                }  
                                var user1 = "";
                                for (var j = 0; j < round.teams[1].users.length; j++) {
                                    var user = round.teams[1].users[j];
                                    user1 = user.username + " " + user1;                    
                                }  

                                var users = user0 + "     VS     " + user1;
                                if (round.teams[0].name === 0 && round.teams[1].name === 0){
                                    //var fieldRound = { name: users, value: '\u200b', inline: false };
                                    //fieldsRounds.push(fieldRound);
                                    embed.addField(users, '\u200b', false) 
                                } else {                            
                                    //var fieldRound = { name: teams, value: users, inline: false };
                                    //fieldsRounds.push(fieldRound);
                                    embed.addField(teams, users, false) 
                                }
                            }
                            embed.setImage(object.image)
                                .setTimestamp()
                                .setFooter({ text: 'Creato da quel pezzente di '  + object.author, iconURL: object.guild_image });
                            const rowInfo1 = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('tournament_review1')
                                    .setLabel("QUESTA E' UN ANTEPRIMA, SOLO TU PUOI VEDERLO!")
                                    .setStyle(ButtonStyle.Danger)
                                    .setDisabled(true),
                            );
                            const rowInfo2 = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('tournament_review2')
                                    .setLabel("PREMI 'PUBBLICA' PER PUBBLICARE IL TORNEO")
                                    .setStyle(ButtonStyle.Danger)
                                    .setDisabled(true),
                            );
                            const rowInfo3 = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('tournament_review3')
                                    .setLabel("OPPURE 'RIGENERA' PER RIGENERARE LE SQUADRE")
                                    .setStyle(ButtonStyle.Danger)
                                    .setDisabled(true),
                            );
                            const row = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('tournament_regen')
                                    .setLabel('Rigenera')
                                    .setStyle(ButtonStyle.Primary),
                            )
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('tournament_publish')
                                    .setLabel('Pubblica')
                                    .setStyle(ButtonStyle.Primary),
                            )
                            interaction.reply({ ephemeral: true, embeds: [ embed ], components: [rowInfo1,rowInfo2,rowInfo3,row] });   
                        } catch (error) {
                            interaction.reply({ content: 'Si è verificato un errore', ephemeral: true });
                            console.error(error);
                        }
                    });
                
                });
                
                req.write(bodyData);
                req.end();
            } else if(interaction.customId === 'tournament_publish'){
                await interaction.reply({ embeds: [ interaction.message.embeds[0] ], ephemeral: false });
            } else if(interaction.customId === 'stop'){
                connection = getVoiceConnection(interaction.member.voice.guild.id);
                if (connection !== null
                    && connection !== undefined){
                        if ( connection !== null 
                            && connection !== undefined
                            && connection.state !== null  
                            && connection.state !== undefined
                            && connection.state.subscription !== null 
                            && connection.state.subscription !== undefined
                            && connection.state.subscription.player !== null 
                            && connection.state.subscription.player !== undefined){
                                connection.state.subscription.player.stop();
                        }
                        await interaction.reply({ content: 'Il pezzente ha smesso di riprodurre', ephemeral: true });
                    } else {
                        await interaction.reply({ content: 'Il pezzente non sta riproducendo nulla', ephemeral: true });
                    }
            } else if(interaction.customId === 'leave'){
                connection = getVoiceConnection(interaction.member.voice.guild.id);
                if (connection !== null
                    && connection !== undefined){
                        connection.destroy();
                        await interaction.reply({ content: 'Il pezzente è uscito dal canale', ephemeral: true });
                    } else {
                        await interaction.reply({ content: 'Il pezzente non si trova in nessun canale', ephemeral: true });
                    }
            }else if(interaction.customId === 'insult'){
                if (!interaction.member._roles.includes(config.ENABLED_ROLE)){
                    interaction.reply({ content: "Non sei abilitato all'utilizzo di questo bot.", ephemeral: true });
                } else if (interaction.member.voice === null 
                    || interaction.member.voice === undefined 
                    || interaction.member.voice.channelId === null 
                    || interaction.member.voice.channelId === undefined ){
                        interaction.reply({ content: 'Devi prima entrare in un canale vocale', ephemeral: true });
                } else if (interaction.member.voice !== null 
                    && interaction.member.voice !== undefined 
                    && interaction.member.voice.channelId !== null 
                    && interaction.member.voice.channelId !== undefined
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_1
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_2
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_3
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_4){
                        interaction.reply({ content: "Impossibile utilizzare questo comando in questo canale vocale.", ephemeral: true });
                } else {
                    const connection_old = getVoiceConnection(interaction.member.voice.guild.id);
                    if (connection_old !== null 
                        && connection_old !== undefined
                        && connection_old.joinConfig.channelId !== interaction.member.voice.channelId){
                            if (connection_old !== undefined 
                                && connection_old !== null) {
                                    connection_old.destroy();
                                }
                        connection = joinVoiceChannel({
                            channelId: interaction.member.voice.channelId,
                            guildId: interaction.guildId,
                            adapterCreator: interaction.guild.voiceAdapterCreator,
                            selfDeaf: false,
                            selfMute: false
                        });

                        connection.on(VoiceConnectionStatus.Disconnected, async (oldState, newState) => {
                            try {
                                await Promise.race([
                                    entersState(connection, VoiceConnectionStatus.Signalling, 5_000),
                                    entersState(connection, VoiceConnectionStatus.Connecting, 5_000),
                                ]);
                                // Seems to be reconnecting to a new channel - ignore disconnect
                            } catch (error) {
                                // Seems to be a real disconnect which SHOULDN'T be recovered from
                                connection.destroy();
                            }
                        });
                    } else {
                        connection = connection_old;
                    }
                    
                    
    
                    var guildid=""
                    if(interaction.member.voice.guild.id === GUILD_ID){
                        guildid="000000"
                    }
                    else{
                        guildid = interaction.member.voice.guild.id
                    }
                    var params = api+path_audio+"insult?text=none&chatid="+encodeURIComponent(guildid);
    
    
                    fetch(
                        params,
                        {
                            method: 'GET',
                            headers: { 'Accept': '*/*' }
                        }
                    ).then(res => {
                        if(!res.ok) {
                            console.error("ERRORE!", text);    
                            interaction.editReply({ content: 'Si è verificato un errore', ephemeral: true });           
                        } else {
                            new Promise((resolve, reject) => {
                                var file = Math.random().toString(36).slice(2)+".mp3";
                                //var file = "temp.mp3";
                                let outFile = path+"/"+file;
                                const dest = fs.createWriteStream(outFile);
                                res.body.pipe(dest);
                                res.body.on('end', () => resolve());
                                dest.on('error', reject);        
        
        
                                dest.on('finish', function(){            
                                    let resource = createAudioResource(outFile); //let resource = createAudioResource(createReadStream(outFile));
                                    if ( connection !== null 
                                        && connection !== undefined
                                        && connection.state !== null  
                                        && connection.state !== undefined
                                        && connection.state.subscription !== null 
                                        && connection.state.subscription !== undefined
                                        && connection.state.subscription.player !== null 
                                        && connection.state.subscription.player !== undefined){
                                            connection.state.subscription.player.play(resource);
                                    } else {
                                        connection.subscribe(player);
                                        player.play(resource);
                                    }

                                    
                                    //setTimeout(() => unsubscribeConnection(), 15_000)
                                    console.log('Il pezzente sta insultando');
                                    interaction.editReply({ content: 'Il pezzente sta insultando', ephemeral: true });          
                                });
                            }).catch(function(error) {
                                console.error("ERRORE!", "["+ error + "]");
                                interaction.editReply({ content: 'Si è verificato un errore\n' + error.message, ephemeral: true });   
                            }); 
                        }
                    }).catch(function(error) {
                        console.error("ERRORE!", "["+ error + "]");
                        interaction.reply({ content: 'Si è verificato un errore', ephemeral: true });   
                    }); 
                }
            }
        } else if (interaction.isStringSelectMenu()) {
            if(interaction.customId === 'videoselect'){
                if (!interaction.member._roles.includes(config.ENABLED_ROLE)){
                    interaction.reply({ content: "Non sei abilitato all'utilizzo di questo bot.", ephemeral: true });
                } else if (interaction.member.voice === null 
                    || interaction.member.voice === undefined 
                    || interaction.member.voice.channelId === null 
                    || interaction.member.voice.channelId === undefined ){
                        interaction.reply({ content: 'Devi prima entrare in un canale vocale', ephemeral: true });
                } else if (interaction.member.voice !== null 
                    && interaction.member.voice !== undefined 
                    && interaction.member.voice.channelId !== null 
                    && interaction.member.voice.channelId !== undefined
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_1
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_2
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_3
                    && interaction.member.voice.channelId !== config.ENABLED_CHANNEL_ID_4){
                        interaction.reply({ content: "Impossibile utilizzare questo comando in questo canale vocale.", ephemeral: true });
                } else {
                    const connection_old = getVoiceConnection(interaction.member.voice.guild.id);
                    if ((connection_old === undefined 
                        || connection_old === null) 
                        || 
                        (connection_old !== null 
                        && connection_old !== undefined
                        && connection_old.joinConfig.channelId !== interaction.member.voice.channelId)){
                            if (connection_old !== undefined 
                                && connection_old !== null) {
                                    connection_old.destroy();
                                }
                        
                            connection = joinVoiceChannel({
                                channelId: interaction.member.voice.channelId,
                                guildId: interaction.guildId,
                                adapterCreator: interaction.guild.voiceAdapterCreator,
                                selfDeaf: false,
                                selfMute: false
                            });

                            connection.on(VoiceConnectionStatus.Disconnected, async (oldState, newState) => {
                                try {
                                    await Promise.race([
                                        entersState(connection, VoiceConnectionStatus.Signalling, 5_000),
                                        entersState(connection, VoiceConnectionStatus.Connecting, 5_000),
                                    ]);
                                    // Seems to be reconnecting to a new channel - ignore disconnect
                                } catch (error) {
                                    // Seems to be a real disconnect which SHOULDN'T be recovered from
                                    connection.destroy();
                                }
                            });
                        } else {
                            connection = connection_old;
                        }
                    if (connection){
                        var video = interaction.values[0];
                        var params = api+path_music+'youtube/get?url='+encodeURIComponent(video);
                        await interaction.deferUpdate();
                        fetch(
                            params,
                            {
                                method: 'GET',
                                headers: { 'Accept': '*/*' }
                            }
                        ).then(res => {
                            if(!res.ok) {
                                res.text().then((text) => {
                                    console.error("ERRORE!", text);
                                    interaction.editReply({ content: "Errore!: \n\n" + text, ephemeral: true });
                                });       
                            } else {
                                new Promise((resolve, reject) => {
                                    var file = "youtube.mp3";
                                    //var file = "temp.mp3";
                                    let outFile = path+"/"+file;
                                    const dest = fs.createWriteStream(outFile);
                                    res.body.pipe(dest);
                                    res.body.on('end', () => resolve());
                                    dest.on('error', reject);        

                                    dest.on('finish', function(){
                                        let resource = createAudioResource(outFile); //let resource = createAudioResource(createReadStream(outFile));


                                        
                                        //setTimeout(() => unsubscribeConnection(), 15_000)
                                        console.log('youtube.mp3');
                                        const row = new ActionRowBuilder()
                                        .addComponents(
                                            new ButtonBuilder()
                                                .setCustomId('stop')
                                                .setLabel('Stop')
                                                .setStyle(ButtonStyle.Primary),
                                        );
                                        const options = {
                                            "method": "GET",
                                            "hostname": hostname,
                                            "port": port,
                                            "path": path_music+'youtube/info?url='+encodeURIComponent(video)
                                        }
                                        const req = http.request(options, function(res) {
                    
                                            var chunks = [];
                                        
                                            req.on('error', function (error) {
                                                console.error("ERRORE!", "["+ error + "]");
                                                interaction.reply({ content: 'Si è verificato un errore', ephemeral: true }); 
                                            });
                                            res.on("data", function (chunk) {
                                                chunks.push(chunk);
                                            });
                                        
                                            res.on("end", function() {
                                                try {
                                                    var body = Buffer.concat(chunks);
                                                    var object = JSON.parse(body.toString())
                                                    
                                                    const rowStop = new ActionRowBuilder()
                                                    .addComponents(
                                                        new ButtonBuilder()
                                                            .setCustomId('stop')
                                                            .setLabel('Stop')
                                                            .setStyle(ButtonStyle.Primary),
                                                    );
                                                    if (object.length === 0) {                                
                                                        interaction.editReply({ content: 'Il pezzente sta riproducendo', ephemeral: false, components: [rowStop] });  
                                                    } else {
                                                    var videores = object[0];
                                                    const embed = new EmbedBuilder()
                                                            .setColor('#0099ff')
                                                            .setTitle(videores.title)
                                                            .setURL(videores.link)
                                                            .setDescription(videores.link);
                                                    
                                                    interaction.editReply({ content: 'Il pezzente sta riproducendo', ephemeral: false, embeds: [embed], components: [rowStop] });  
                                                    }
                                                
                                                } catch (error) {
                                                    interaction.editReply({ content: 'Si è verificato un errore\n' + error.message, ephemeral: true });
                                                    console.error(error);
                                                }
                                            });
                                        
                                        });        
                                        
                                        req.end()  
                                    });
                                }).catch(function(error) {
                                    console.error("ERRORE!", "["+ error + "]");
                                    interaction.editReply({ content: 'Si è verificato un errore\n' + error.message, ephemeral: true });   
                                }); 
                            }
                        }).catch(function(error) {
                            console.error("ERRORE!", "["+ error + "]");
                            interaction.editReply({ content: 'Si è verificato un errore\n' + error.message, ephemeral: true });
                        });
                    } else {                
                        await interaction.reply({ content: 'Si è verificato un errore', ephemeral: true });
                    }
                }
            }
        }
    } catch (error) {
        await interaction.reply({ content: 'Si è verificato un errore', ephemeral: true });
        console.error(error);
    }
});

client.on("messageDelete", (messageDelete) => {

    if (messageDelete.channel.id === MESSAGES_CHANNEL_ID){
        console.log("Someone deleted:" + messageDelete.content);
        var params = api+path_text+"admin/forcedelete/bytext/"+encodeURIComponent(config.ADMIN_PASS)+"/"+encodeURIComponent(messageDelete.content);
        fetch(
        params,
            {
                method: 'GET',
                headers: { 'Accept': '*/*' }
            }
        ).catch(function(error) {
            console.error("ERRORE!", "["+ error + "]");
        });
    }

});

client.on("messageCreate", (msg) => {
        try{            
            if (msg.channelId === '972093345306411010' && !msg.member?.user.bot) {
                msg.delete();
            }
            if (msg.member?.voice !== null
                && msg.member?.voice != undefined
                && msg.member?.voice.channel != null
                && msg.member?.voice.channel != undefined) {
                if (msg.member?.voice.channel.id === config.ENABLED_CHANNEL_ID_1
                    || msg.member?.voice.channel.id === config.ENABLED_CHANNEL_ID_2
                    || msg.member?.voice.channel.id === config.ENABLED_CHANNEL_ID_3){                    
                    const connection_old = getVoiceConnection(msg.member?.voice.guild.id);
                    if ((connection_old === undefined 
                        || connection_old === null) 
                        || 
                        (connection_old !== null 
                        && connection_old !== undefined
                        && connection_old.joinConfig.channelId !== msg.member?.voice.channel.id)){
                        //&& connection_old.joinConfig.channelId !== newMember?.channelId)){
                if (connection_old !== undefined 
                    && connection_old !== null) {
                        connection_old.destroy();
                    }
                            connection = joinVoiceChannel({
                                channelId: msg.member?.voice.channel.id,
                                guildId: msg.member?.voice.channel.guild.id,
                                adapterCreator: msg.member?.voice.channel.guild.voiceAdapterCreator,
                                selfDeaf: false,
                                selfMute: false
                            });

                            connection.on(VoiceConnectionStatus.Disconnected, async (oldState, newState) => {
                                try {
                                    await Promise.race([
                                        entersState(connection, VoiceConnectionStatus.Signalling, 5_000),
                                        entersState(connection, VoiceConnectionStatus.Connecting, 5_000),
                                    ]);
                                    // Seems to be reconnecting to a new channel - ignore disconnect
                                } catch (error) {
                                    // Seems to be a real disconnect which SHOULDN'T be recovered from
                                    connection.destroy();
                                }
                            });
                    } else {
                            connection = connection_old;
                    }
                }
            }
        } catch (error) {
            console.error(error);
        }
    });
  
    

client.on("speech", (msg) => {

    try{
        let content;
        if( msg.content
            && msg.content !== ''
            && msg.content !== 'undefined') {
            content = msg.content;
        } 
        //if (msg.error) {
        //    console.error("ERRORE!", "[onSpeechError: "+ msg.error + "]");
        //}
             
        const connection = getVoiceConnection(msg.member?.voice.guild.id);
        if(connection !== null && connection !== undefined
            && config.ENABLED) {

            var bcAuto = false;
            var bcSpeech = false;

            if(config.AUTONOMOUS) {
                bcAuto = true;
            } else if ( content && 
                (new RegExp('^pezzente', "i").test(content.toLowerCase()) 
                || new RegExp('^scemo', "i").test(content.toLowerCase()) 
                || new RegExp('^bot', "i").test(content.toLowerCase()) 
                || new RegExp('^boat', "i").test(content.toLowerCase()))) {
                bcSpeech = true;
            }
            


            differenctMs = (new Date()).getTime() - lastSpeech;

            if (content && 
                (new RegExp('^disabilita', "i").test(content.toLowerCase())
                || new RegExp('^disable', "i").test(content.toLowerCase()))) {
                config.AUTONOMOUS = false;
            } else if ((bcAuto && (differenctMs > config.AUTONOMOUS_TIMEOUT)) || bcSpeech) {
                lastSpeech = (new Date()).getTime();
                

                if ( content === undefined || content === null ) {
                    var url = api+path_text+"random/";
                    try {
                        content = syncfetch(url).text();
                    } catch (error) {
                        console.error("ERRORE!", "["+ error + "]");
                    } 
                }
                    
                var words = content.toLowerCase()
                if(!config.AUTONOMOUS){
                    words = content.toLowerCase()
                    .replace(/pezzente/, "")
                    .replace(/scemo/, "")
                    .replace(/bot/, "")
                    .replace(/boat/, "")
                    .trim();
                }

                if (words === ''){
                    words = content.toLowerCase();
                }

                var params = ""
                /**if(bcAuto) {
                    params = api+path_audio+"ask/"+config.AUTONOMOUS_TIMEOUT+"/"+words;
                } else {
                    params = api+path_audio+"ask/"+words;
                }*/
                var guildid=""
                if(msg.guild.id === GUILD_ID){
                    guildid="000000"
                }
                else{
                    guildid = msg.guild.id
                }
                params = api+path_audio+"ask/nolearn/random/"+encodeURIComponent(words)+"/"+encodeURIComponent(guildid);
                fetch(
                    params,
                    {
                        method: 'GET',
                        headers: { 'Accept': '*/*' }    
                    }
                ).then(res => {
                    if(!res.ok) {
                        res.text().then((text) => {
                            console.error("ERRORE!", text);
                        }); 
                    } else {
                        new Promise((resolve, reject) => {
                            var file = Math.random().toString(36).slice(2)+".mp3";
                            //var file = "temp.mp3";
                            let outFile = path+"/"+file;
                            const dest = fs.createWriteStream(outFile);
                            res.body.pipe(dest);
                            res.body.on('end', () => resolve());
                            dest.on('error', reject);        
                            dest.on('finish', function(){     
                                let resource = createAudioResource(outFile); //let resource = createAudioResource(createReadStream(outFile));
                                if ( connection !== null 
                                    && connection !== undefined
                                    && connection.state !== null  
                                    && connection.state !== undefined
                                    && connection.state.subscription !== null 
                                    && connection.state.subscription !== undefined
                                    && connection.state.subscription.player !== null 
                                    && connection.state.subscription.player !== undefined){
                                        connection.state.subscription.player.play(resource);
                                } else {
                                    connection.subscribe(player);
                                    player.play(resource);
                                }
                                
                                //setTimeout(() => unsubscribeConnection(), 15_000) 
                            });
                            var params = api+path_text+"lastsaid/"+encodeURIComponent(words)+"/"+encodeURIComponent(guildid);
                            fetch(
                                params,
                                {
                                    method: 'GET',
                                    headers: { 'Accept': '*/*' }
                                }
                            ).then((result) => result.text())
                            .then((res) => {
                                try {
                                    client.guilds.cache.get(config.GUILD_ID).channels.cache.get(MESSAGES_CHANNEL_ID).send(res);
                                } catch (error) {
                                    console.error("ERRORE!", "["+ error + "]");
                                }
                            }).catch(function(error) {
                                console.error("ERRORE!", "["+ error + "]");
                            }); 
                            //console.log("Speech running.", "[differenctMs: " + differenctMs +"]", "[bcSpeech: " + bcSpeech +"]", "[bcAuto: " +bcAuto +"]", "[config.AUTONOMOUS: " + config.AUTONOMOUS +"]", "[msg.content: " + msg.content +"]");
                        }).catch(function(error) {
                            console.error("ERRORE!", "["+ error + "]");
                        }); 
                    }
                }).catch(function(error) {
                    console.error("ERRORE!", "["+ error + "]");
                }); 
            } else if (content && (content.toLowerCase().includes('stop') || content.toLowerCase().includes('ferma'))) {
                    player.stop();
            //} else {
            //    console.log("Speech not running.", "[differenctMs: " + differenctMs +"]", "[bcSpeech: " + bcSpeech +"]", "[bcAuto: " +bcAuto +"]", "[config.AUTONOMOUS: " + config.AUTONOMOUS +"]", "[msg.content: " + msg.content +"]");
            } 
        }
      } catch (error) {
        console.error(error);
      }
    });





client.login(TOKEN);
